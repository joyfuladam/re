// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CollaboratorRole {
  musician
  writer
  producer
  artist
  vocalist
  label
}

enum MasterRevenueScope {
  digital_only
  full
}

enum ContractType {
  digital_master_only
  songwriter_publishing
  producer_agreement
  label_record
}

enum ContractStatus {
  pending
  signed
  expired
}

enum SplitType {
  publishing
  master
}

enum UserRole {
  admin
  collaborator
}

enum NotificationType {
  MESSAGE
  CONTRACT
  SYSTEM
}

model Collaborator {
  id                 String             @id @default(cuid())
  firstName          String
  middleName         String?
  lastName           String
  email              String?            @unique // Optional - only needed for login accounts
  emailVerified      DateTime?
  password           String? // Hashed password for authentication
  image              String?
  role               UserRole           @default(collaborator) // admin or collaborator
  phone              String?
  address            String?
  capableRoles       CollaboratorRole[] // Multiple roles this person can perform (musician, writer, producer)
  // Industry fields
  proAffiliation     String? // ASCAP, BMI, SESAC
  ipiNumber          String?
  taxId              String? // Encrypted in application
  publishingCompany  String?
  managerName        String?
  managerEmail       String?
  managerPhone       String?
  royaltyAccountInfo String?
  // Social Media
  instagramHandle    String?
  facebookUrl        String?
  tiktokHandle       String?
  twitterHandle      String?
  youtubeUrl         String?
  spotifyArtistUrl   String?
  // Metadata
  notes              String?
  status             String             @default("active") // active, inactive
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  // Relations
  songCollaborators  SongCollaborator[]
  accounts           Account[]
  sessions           Session[]
  messageParticipants MessageParticipant[]
  sentMessages        Message[]
  notifications       Notification[]
  createdThreads      MessageThread[]
}

model Account {
  id                String  @id @default(cuid())
  collaboratorId    String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  collaborator Collaborator @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id             String       @id @default(cuid())
  sessionToken   String       @unique
  collaboratorId String
  expires        DateTime
  collaborator   Collaborator @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Song {
  id                        String                 @id @default(cuid())
  title                     String
  isrcCode                  String?                @unique
  iswcCode                  String?
  catalogNumber             String?
  releaseDate               DateTime?
  // Industry fields
  proWorkRegistrationNumber String?
  publishingAdmin           String?
  masterOwner               String?
  genre                     String?
  subGenre                  String?
  duration                  Int? // in seconds
  recordingDate             DateTime?
  recordingLocation         String?
  // Split status
  publishingLocked          Boolean                @default(false)
  publishingLockedAt        DateTime?
  masterLocked              Boolean                @default(false)
  masterLockedAt            DateTime?
  labelMasterShare          Decimal?               @db.Decimal(5, 4) // 0.0000 to 1.0000 (e.g., 0.5000 = 50%)
  // Metadata
  status                    String                 @default("draft") // draft, active, archived
  notes                     String?
  promoMaterialsFolderId    String? // Google Drive folder ID for promo materials
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  // Relations
  songCollaborators         SongCollaborator[]
  songPublishingEntities    SongPublishingEntity[]
  contracts                 Contract[]
  splitHistory              SplitHistory[]
  emailLogs                 EmailLog[]
  media                     SongMedia[]
  adDrafts                  AdDraft[]
  smartLinks                SmartLink[]
  messageThreads            MessageThread[]
}

model SongCollaborator {
  id                  String           @id @default(cuid())
  songId              String
  collaboratorId      String
  roleInSong          CollaboratorRole
  publishingOwnership Decimal?         @db.Decimal(5, 4) // 0.0000 to 1.0000
  masterOwnership     Decimal?         @db.Decimal(5, 4) // 0.0000 to 1.0000
  contractStatus      ContractStatus   @default(pending)
  contractType        ContractType?
  notes               String?
  addedDate           DateTime         @default(now())
  // Relations
  song                Song             @relation(fields: [songId], references: [id], onDelete: Cascade)
  collaborator        Collaborator     @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)
  contracts           Contract[]

  @@unique([songId, collaboratorId, roleInSong]) // Allow same collaborator with different roles
  @@index([songId])
  @@index([collaboratorId])
}

model PublishingEntity {
  id                     String                 @id @default(cuid())
  name                   String // e.g., "River & Ember Publishing", "Sony Music Publishing"
  isInternal             Boolean                @default(false) // true for River & Ember, false for co-pubs
  contactName            String?
  contactEmail           String?
  contactPhone           String?
  address                String?
  proAffiliation         String? // ASCAP, BMI, SESAC
  notes                  String?
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  // Relations
  songPublishingEntities SongPublishingEntity[]

  @@index([name])
  @@index([isInternal])
}

model SongPublishingEntity {
  id                  String           @id @default(cuid())
  songId              String
  publishingEntityId  String
  ownershipPercentage Decimal          @db.Decimal(5, 4) // 0.0000 to 1.0000 (e.g., 0.5000 = 50%)
  notes               String?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  // Relations
  song                Song             @relation(fields: [songId], references: [id], onDelete: Cascade)
  publishingEntity    PublishingEntity @relation(fields: [publishingEntityId], references: [id], onDelete: Cascade)

  @@unique([songId, publishingEntityId])
  @@index([songId])
  @@index([publishingEntityId])
}

model Contract {
  id                 String           @id @default(cuid())
  songId             String
  collaboratorId     String
  songCollaboratorId String
  templateType       ContractType
  pdfPath            String?
  pdfUrl             String?
  // E-signature
  esignatureStatus   String?          @default("pending") // pending, sent, signed, declined
  esignatureDocId    String? // HelloSign document ID
  signerEmail        String?
  signedAt           DateTime?
  signedPdfData      Bytes?
  // Revenue scope
  revenueScope       Json? // Allowed/disallowed revenue streams
  // Metadata
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  // Relations
  song               Song             @relation(fields: [songId], references: [id], onDelete: Cascade)
  songCollaborator   SongCollaborator @relation(fields: [songCollaboratorId], references: [id], onDelete: Cascade)
  notifications      Notification[]

  @@unique([songCollaboratorId, templateType]) // Prevent duplicate contracts for same collaborator/type
  @@index([songId])
  @@index([collaboratorId])
  @@index([esignatureStatus])
}

model ContractTemplate {
  id              String       @id @default(cuid())
  name            String
  type            ContractType @unique
  content         String       @db.Text // HTML/Markdown with placeholders
  pdfStyling      Json? // PDF styling configuration
  roleRestriction String[] // Which roles can use this template
  isActive        Boolean      @default(true)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
}

model SplitHistory {
  id             String    @id @default(cuid())
  songId         String
  splitType      SplitType
  previousValues Json // Previous split values
  newValues      Json // New split values
  changedBy      String // User ID
  timestamp      DateTime  @default(now())
  // Relations
  song           Song      @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@index([songId])
  @@index([timestamp])
}

model SongMedia {
  id          String   @id @default(cuid())
  songId      String
  category    String   // "audio", "images", "videos"
  filename    String   // original filename
  storagePath String   // path on volume, e.g. "songs/abc123/audio/master.wav"
  mimeType    String   // e.g. "audio/wav", "image/jpeg", "video/mp4"
  fileSize    Int      // bytes
  label       String?  // optional user label, e.g. "Final Master", "Album Art"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  song        Song     @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@index([songId])
  @@index([category])
}

model AdDraft {
  id             String    @id @default(cuid())
  songId         String
  name           String    // admin-friendly label
  headline       String    // ad headline text
  primaryText    String    @db.Text // main ad copy
  callToAction   String?   // e.g. "Listen Now", "Pre-Save"
  destinationUrl String?   // link the ad points to
  imageMediaId   String?   // selected SongMedia for image creative
  videoMediaId   String?   // selected SongMedia for video creative
  audioMediaId   String?   // selected SongMedia for audio (if applicable)
  format         String    // "image", "video", "carousel"
  status         String    @default("draft") // "draft", "ready"
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  song           Song      @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@index([songId])
}

model SmartLink {
  id          String                  @id @default(cuid())
  songId      String
  slug        String                  @unique
  title       String
  description String?
  imageUrl    String?
  isActive    Boolean                 @default(true)
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt
  // Relations
  song        Song                    @relation(fields: [songId], references: [id], onDelete: Cascade)
  destinations SmartLinkDestination[]
  clicks      SmartLinkClick[]
  signups     SmartLinkSignup[]

  @@index([songId])
}

model SmartLinkDestination {
  id          String    @id @default(cuid())
  smartLinkId String
  serviceKey  String    // e.g. "spotify", "apple_music", "amazon", "deezer", "tidal", "youtube"
  label       String    // Button label shown to fans
  url         String    // Outbound URL
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  // Relations
  smartLink   SmartLink @relation(fields: [smartLinkId], references: [id], onDelete: Cascade)

  @@index([smartLinkId])
  @@index([serviceKey])
}

model SmartLinkClick {
  id          String    @id @default(cuid())
  smartLinkId String
  serviceKey  String
  userAgent   String?   @db.Text
  country     String?
  referrer    String?   @db.Text
  createdAt   DateTime  @default(now())
  // Relations
  smartLink   SmartLink @relation(fields: [smartLinkId], references: [id], onDelete: Cascade)

  @@index([smartLinkId])
  @@index([serviceKey])
  @@index([createdAt])
}

model SmartLinkSignup {
  id          String    @id @default(cuid())
  smartLinkId String
  name        String?
  email       String
  createdAt   DateTime  @default(now())
  // Relations
  smartLink   SmartLink @relation(fields: [smartLinkId], references: [id], onDelete: Cascade)

  @@index([smartLinkId])
  @@index([email])
  @@index([createdAt])
}

model FaqSubmission {
  id        String   @id @default(cuid())
  name      String
  email     String
  subject   String
  message   String   @db.Text
  read      Boolean  @default(false)
  readAt    DateTime?
  readBy    String? // Admin user ID who marked it as read
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([read])
  @@index([createdAt])
}

model AccountRequest {
  id          String    @id @default(cuid())
  firstName   String
  lastName    String
  email       String    @unique
  status      String    @default("pending") // pending, approved, rejected
  approvedBy  String? // Admin collaborator ID who approved
  approvedAt  DateTime?
  rejectedBy  String? // Admin collaborator ID who rejected
  rejectedAt  DateTime?
  setupToken  String?   @unique // Token for password setup link
  tokenExpiry DateTime? // Token expiration
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([email])
  @@index([status])
  @@index([createdAt])
}

model EmailTemplate {
  id        String   @id @default(cuid())
  name      String
  subject   String
  bodyHtml  String?  @db.Text
  bodyText  String?  @db.Text
  scope     String?  // optional hint for intended use (e.g. collaborator, song, global)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  emailLogs EmailLog[]
}

model EmailLog {
  id               String         @id @default(cuid())
  templateId       String?
  template         EmailTemplate? @relation(fields: [templateId], references: [id])
  subject          String
  bodyHtml         String?        @db.Text
  bodyPreview      String?        @db.Text
  scope            String
  songId           String?
  song             Song?          @relation(fields: [songId], references: [id])
  recipientCount   Int
  recipientEmails  String?        @db.Text // comma-separated list or JSON string of emails
  triggeredById    String?        // Collaborator ID of the admin who triggered the send
  triggeredByEmail String?
  createdAt        DateTime       @default(now())
  messages         Message[]

  @@index([templateId])
  @@index([songId])
  @@index([createdAt])
}

model MessageThread {
  id          String              @id @default(cuid())
  subject     String
  songId      String?
  createdById String
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Relations
  song         Song?              @relation(fields: [songId], references: [id], onDelete: SetNull)
  createdBy    Collaborator       @relation(fields: [createdById], references: [id], onDelete: Cascade)
  participants MessageParticipant[]
  messages     Message[]

  @@index([songId])
  @@index([createdById])
  @@index([updatedAt])
}

model MessageParticipant {
  id         String         @id @default(cuid())
  threadId   String
  userId     String
  lastReadAt DateTime?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  // Relations
  thread MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   Collaborator @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId])
  @@index([threadId])
}

model Message {
  id         String         @id @default(cuid())
  threadId   String
  senderId   String
  bodyHtml   String?        @db.Text
  bodyText   String?        @db.Text
  emailLogId String?
  createdAt  DateTime       @default(now())

  // Relations
  thread    MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender    Collaborator  @relation(fields: [senderId], references: [id], onDelete: Cascade)
  emailLog  EmailLog?     @relation(fields: [emailLogId], references: [id])
  notifications Notification[]

  @@index([threadId])
  @@index([senderId])
  @@index([emailLogId])
  @@index([createdAt])
}

model Notification {
  id         String           @id @default(cuid())
  userId     String
  type       NotificationType
  messageId  String?
  contractId String?
  metadata   Json?
  createdAt  DateTime         @default(now())
  readAt     DateTime?

  // Relations
  user     Collaborator @relation(fields: [userId], references: [id], onDelete: Cascade)
  message  Message?     @relation(fields: [messageId], references: [id])
  contract Contract?    @relation(fields: [contractId], references: [id])

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([readAt])
}
